---
title: "Modena Time Series Analysis"
output:
  html_document:
    df_print: paged
    toc: yes
  word_document:
    toc: yes
  html_notebook:
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
---

# Introduction

This R notebook provides code to reproduce results for the paper *Effects of antimicrobial stewardship and infection prevention and control on the incidence of carbapenem resistant gram-negative infections in Modena, Italy: a non-linear time-series analysis*. It requires installing of necessary packages

Data and code are available at the Github repository [via this link](https://github.com/TimLawes/modena_carbapenem_resistance)

# 1. Preliminaries

## 1.1 Install copies of required packages to private library

```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}

# Install renv for private package library if not available
if(!require(renv)){
    install.packages("renv",destdir = "C://R",dependencies = TRUE)
}

Sys.setenv(LOCALAPPDATA=renv::paths$library())
renv::restore()



```

## 1.2 Load required packages and customised plot theme

```{r warning=FALSE, include=FALSE, messages=FALSE}

# optional:  
# package.list<-c('tidyverse','earth','tseries','tsutils','forecast','fpp3','plotmo','mgcv','smooth','lmtest','stats','grid','lattice','viridis','hrbrthemes','sysfonts','lubridate','car','strucchange','ganttrify','patchwork','missForest','mgcViz','lmtest','feasts','fpp3','AID','devtools') 
# install.packages(package.list, destdir = "C://R",dependencies = TRUE)

library(tidyverse) # to enable tidyverse functions   install.packages("package",destdir = "C://R")
library(earth) # for MARS
library(tseries) # for working with TS data
library(tsutils) # install.packages("tsutils",destdir = "C://R")
library(forecast) # for forcasting
library(fpp3) # enables tsibble, and fable packages
library(plotmo) # plotting MARS model from earth
library(mgcv) # for GLM and GAM models
library(smooth) # install.packages("smooth",destdir = "C://R")
library(lmtest) # comparing models 
library(stats)
library(grid)
library(lattice) # install.packages("lattice",destdir = "C://R")
library(viridis) # for viridis colour palettes
library(hrbrthemes) #for plot themes
library(sysfonts) # for using google fonts
library(lubridate) # for working with datetime variables
library(car) # for Cook's distances
library(strucchange) # for detecting structural changes in time-series
library(ganttrify) # for time lines (Gantt type)
library(patchwork) # for combining different plot types
library(missForest) # for missing value imputation by random forest
library(mgcViz) # for plots and model checks of GAM
library(tsibble)
library(lmtest)
library(feasts)
library(fpp3)
library(AID)
library(readxl)
library(vars) # VARS/vECM model functions
library(urca) # Johansen and related cointegration tests
library(MTS)
library(timetk)

source("cochrane_plot_theme.R") # imports a custom ggplot theme defined in other script
source("OutlierTreatment2.R") # imports custom function for detecting extreme outliers and replacing.
```

## 1.3 Load data and process

```{r warning=FALSE, include=FALSE, messages=FALSE, results='hide'}

# Read in the main data 
main <- read_excel("../Data/raw data/modena_final_2008_2018.xlsx")

date <- yearmonth(seq(as.Date("2008-01-01"), as.Date("2018-12-31"), by = "1 month")) %>% as_tibble() %>% rename(date="value")

main <- cbind(date,main) %>% dplyr::select(!c(study_m, Month))


# Create wide as a time-series indexed table (tsibble)
tswide <- main %>% mutate(
  across(gmneg_all_bsi:crpa_cohca_swab,~./obds*10000),
  across(abhr: rectalswab, ~./obds*1000))  %>% 
  as_tsibble(index = date)


## Outlier detection and time-series cleaning

# outlier detection and replacement with cleaned values
wide_clean <- tswide %>% as_tibble %>% 
  dplyr::select(obds, bedocc, abhr:crpa_cohca_swab)
                                                     
newabx.matrix<-rep(0,132)

for(i in 1:length(wide_clean[1,])){
abx<- wide_clean[,i]
newabx<- OutlierTreatment2(abx,freq=12,start.date=c(2008,1), only.clean=TRUE)
newabx.matrix <-cbind(newabx.matrix, newabx)
}

newabx.matrix<-newabx.matrix[,-1]

colnames(newabx.matrix)<-c(paste0(colnames(wide_clean)))
newabx.matrix<- newabx.matrix[,!colnames(newabx.matrix) %in% 'date']

tmp <-tswide %>% dplyr::select(!c(obds, bedocc, abhr:crpa_cohca_swab))

tswide_clean<-cbind(newabx.matrix,as.data.frame(tmp)) %>% as_tsibble(index=date)
rm(tmp, newab.matrix, date, abx, tswide, wide_clean)

# generate new vars after box-cox transformation
tswide_clean <- tswide_clean %>% mutate(across(
  c(abhr:ecoli_esbl_all_bsi, allab_all_clinical:crpa_cohca_swab, cephs,noncarb), box_cox_vec,.names="{.col}_bc"))


# Derive pre-intervention time-series
ts_p1 <- tswide_clean %>% filter (phase <=1)
ts_p2<- tswide_clean %>% filter (phase <=2)
ts_p3 <- tswide_clean %>% filter (phase <=3)

# Generate long-format data
tslong <- tswide_clean %>% 
  dplyr::select(c(date, phase,
                  allab_all_clinical:crpa_cohca_swab)) %>%
  pivot_longer(
  cols = allab_all_clinical:crpa_cohca_swab,
  names_to = c("IR", "org", "pop", "site"),
  names_pattern = "(cr|cs|all)(ab|kp|pa)_(.*)_(.*)",
  values_to="incidence") %>% filter(pop!="NA")

tslong<- tslong %>% mutate (bugs = paste(IR,org,pop,site))


tslong$phase <-as_factor(tslong$phase)
tslong_p1 <- tslong %>% filter(phase=="1")
tslong_p2 <- tslong %>% filter(phase=="2")
tslong_p3 <- tslong %>% filter(phase=="3")
tslong_p4 <- tslong %>% filter(phase=="4")

```

# 3. Univariate ARIMAs

In addition to time-series decomposition applied to all variables (to facilitate descriptive statistics) we further characterised key time-series, including:

-   Primary outcomes
-   Antibiotic time-series - for counterfactuals
-   Other infection time-series driving antibiotic use


## 3.1 Preparation 

### 3.1.1 Auto arima function
This function creates output from automated ARIMA from the 'forecast' package. 
```{r message=FALSE, warning=FALSE, include=FALSE}

auto.arima.df <- function(data, y, ...){
    y <- enquo(y)
    yts <- data %>% 
        pull(!!y) %>% 
        as.ts()
    auto.arima(yts, ...)
}

```

## 3.2 Primary outcomes
The primary study outcomes of interest are for each CRO
3.2.1   CRKp hca clinical,
3.2.2   CRAb hca clinical,
3.2.3   CRPa hca clinical
3.2.4   CRKp conothca clinical,
3.2.5   CRAb conothca bsi
3.2.6   CRPa hca clinical,

### 3.2.1 Automated
```{r warning=FALSE, include=FALSE, messages=FALSE, results='hide'}
tslong


```
### 3.2.1 HCA-CRKp clinical infections (*crkp_hca_clinical*)

```{r message=FALSE, warning=FALSE, include=TRUE}

#### Plot data, ACF, PACF for series before and after differencing and Box-Cox transformation
tswide_clean %>% gg_tsdisplay(crkp_hca_clinical, "partial")
tswide_clean %>% gg_tsdisplay(difference(crkp_hca_clinical), "partial")
tswide_clean %>% gg_tsdisplay(crkp_hca_clinical_bc, "partial")
tswide_clean %>% gg_tsdisplay(difference(crkp_hca_clinical_bc), "partial")


#### Apply a unit root test to check if time-series stationary,  determine number of non-seasonal (ndiffs) and seasonal (nsdiffs) differences required to make stationary, and plot differenced time-series if required.
tswide_clean %>% features(crkp_hca_clinical_bc, unitroot_kpss)
tswide_clean %>% features(crkp_hca_clinical_bc, unitroot_ndiffs) 
tswide_clean %>% features(crkp_hca_clinical_bc, unitroot_nsdiffs,.period=12) 

### Repeat on differenced series
tswide_clean %>% features(difference(crkp_hca_clinical_bc), unitroot_kpss)
tswide_clean %>% features(difference(crkp_hca_clinical_bc), unitroot_ndiffs) 
tswide_clean %>% features(difference(crkp_hca_clinical_bc), unitroot_nsdiffs,.period=12)

#### Fit best manual and auto ARIMA on transformed data
arima_crkp_hca_bc <- tswide_clean %>% model(
  arima_crkp_hca_bc_111 = ARIMA(box_cox(crkp_hca_clinical ~ pdq(1,1,1)),
  arima_crkp_hca_bc_011 = ARIMA(crkp_hca_clinical_bc ~ pdq(0,1,1)),
  arima_crkp_hca_bc_101 = ARIMA(crkp_hca_clinical_bc ~ pdq(1,0,1)),
  stepwise_crkp_hca  =ARIMA(crkp_hca_clinical_bc))

glance(arima_crkp_hca_bc) %>% arrange(AICc) %>% dplyr::select(.model:BIC)

arima_crkp_hca_bc  %>% dplyr::select(arima_crkp_hca_bc_111) %>% gg_tsresiduals() # compare models
arima_crkp_hca_bc  %>% dplyr::select(arima_crkp_hca_bc_011) %>% gg_tsresiduals() # compare models
arima_crkp_hca_bc  %>% dplyr::select(arima_crkp_hca_bc_101) %>% gg_tsresiduals() # compare models
arima_crkp_hca_bc %>% dplyr::select(stepwise_crkp_hca) %>% gg_tsresiduals() # compare models

#### Check portmanteau tests of best fit options
augment(arima_crkp_hca_bc) %>% 
  filter(.model=='arima_crkp_hca_bc_101') %>%
  features(.innov, ljung_box, lag = 10, dof = 3)  #portmanteau test on best manual

augment(arima_crkp_hca_bc) %>% 
  filter(.model=='stepwise_crkp_hca_bc') %>%
  features(.innov, ljung_box, lag = 10, dof = 3)  #portmanteau test on best manual

### Plotting characteristic roots of best model
tswide_clean %>%
   model(ARIMA(crkp_hca_clinical ~ pdq(0,1,1))) %>%
   gg_arma()
 
### Plotting best-fit model and forecast
augment(arima_crkp_hca_bc) %>% 
  filter(.model=='stepwise_crkp_hca_bc') %>%
  features(.innov, ljung_box, lag = 10, dof = 3)  #portmanteau test on best manual

arima_crkp_hca_bc %>% dplyr::select(arima_crkp_hca_bc_101) %>% fabletools::forecast(h = "3 years")
```

### 3.2.2 HCA-CRAb clinical infections (*crab_hca_clinical*)

```{r message=FALSE, warning=FALSE, include=TRUE}

#### Plot data, ACF, PACF
tswide_clean %>% gg_tsdisplay(crab_hca_clinical, "partial") 

#### Apply a unit root test to check if time-series stationary,  determine number of non-seasonal (ndiffs) and seasonal (nsdiffs) differences required to make stationary, and plot differenced time-series if required.
tswide_clean %>% features(crab_hca_clinical, unitroot_kpss)
tswide_clean %>% features(crab_hca_clinical, unitroot_ndiffs)
tswide_clean %>% features(crab_hca_clinical, unitroot_nsdiffs,.period=12)
tswide_clean %>% gg_tsdisplay(difference(crab_hca_clinical), "partial") 


#### Examine need for a Box-Cox data transformation to reduce heteroskedasticity (i.e variability in the variance of the time-series)
lambda<-guerrero(tswide_clean$crab_hca_clinical, .period=12L)

#### Fit best manual and auto ARIMA on transformed data
arima_crab_ho <- tswide_clean %>% model(
  arima_crab_hca_111 = ARIMA(crab_hca_clinical ~ pdq(1,1,1)),
  arima_crab_hca_011 = ARIMA(crab_hca_clinical ~ pdq(0,1,1)),
  arima_crab_hca_110 = ARIMA(crab_hca_clinical ~ pdq(1,1,0)),
  arima_crab_hca_101 = ARIMA(crab_hca_clinical ~ pdq(1,0,1)),
  stepwise_crab_ho = ARIMA(crab_hca_clinical))

glance(arima_crab_ho) %>% arrange(AICc) %>% dplyr::select(.model:BIC)

# check the residuals of best models to ensure white noise.
arima_crab_ho  %>% dplyr::select(arima_crab_hca_011) %>% gg_tsresiduals() 
arima_crab_ho %>% dplyr::select(arima_crab_hca_101) %>% gg_tsresiduals()

#### Check portmanteau tests of best fit option
augment(arima_crab_ho) %>% 
  filter(.model=='arima_crab_hca_011') %>%
  features(.innov, ljung_box, lag = 10, dof = 3)  # portmanteau test on best manual


```

### 3.2.3 HCA-CRPa clinical infections (*crpa hca clinical*)

```{r message=FALSE, warning=FALSE, include=TRUE}

#### Plot data, ACF, PACF
tswide_clean %>% gg_tsdisplay(crpa_hca_clinical, "partial")

#### Apply a unit root test to check if time-series stationary,  determine number of non-seasonal (ndiffs) and seasonal (nsdiffs) differences required to make stationary, and plot differenced time-series if required.
tswide_clean %>% features(crpa_hca_clinical, unitroot_kpss)
tswide_clean %>% features(crpa_hca_clinical, unitroot_ndiffs) 
tswide_clean %>% features(crpa_hca_clinical, unitroot_nsdiffs,.period=12) 

tswide_clean %>% gg_tsdisplay(difference(crpa_hca_clinical), "partial") 
crpa_hca_clin_diff1 <-  tsibble::difference(tswide_clean$crpa_hca_clinical, lag =1, differences = 1)
tswide_clean %>% gg_tsdisplay(crpa_hca_clin_diff1, "partial")

#### Examine need for a Box-Cox data transformation to reduce heteroskedasticity (i.e variability in the variance of the time-series)
tswide_clean <- tswide_clean %>% dplyr::mutate(crpa_hca_clin_diff1 = replace_na(crpa_hca_clin_diff1, 0))
tswide_clean <- tswide_clean %>% dplyr::mutate(new_crpa_hca_clin_diff1 = crpa_hca_clin_diff1+10)
boxcoxnc(tswide_clean$new_crpa_hca_clin_diff1, method = "sw", lambda2 = 10)


#### Repeat unit root tests and differencing number evaluations on the transformed data
tswide_clean %>% features(crpa_hca_clin_diff1, unitroot_kpss)
tswide_clean %>% features(crpa_hca_clin_diff1, unitroot_ndiffs)
tswide_clean %>% features(crpa_hca_clin_diff1, unitroot_nsdiffs, .period=12)

#### Fit best manual and auto ARIMA
arima_crpa_hca <- tswide_clean %>% model(
  arima_crpa_hca_111 = ARIMA(crpa_hca_clinical ~ pdq(1,1,1)),
  arima_crpa_hca_011 = ARIMA(crpa_hca_clinical ~ pdq(0,1,1)),
  arima_crpa_hca_101 = ARIMA(crpa_hca_clinical ~ pdq(1,0,1)),
  stepwise_crpa_hca = ARIMA(crpa_hca_clinical)) 

glance(arima_crpa_hca) %>% arrange(AICc) %>% dplyr::select(.model:BIC)

#### Examine residuals of ARIMA to check correct identification
arima_crpa_hca  %>% dplyr::select(arima_crpa_hca_011) %>% gg_tsresiduals()
arima_crpa_hca %>% dplyr::select(stepwise_crpa_hca) %>% gg_tsresiduals() 

#### Check portmanteau tests of best fit option
augment(arima_crpa_hca) %>% 
  filter(.model=='arima_crpa_hca_011') %>%
  features(.innov, ljung_box, lag = 10, dof = 3)  # portmanteau test on best manual
```

### 3.2.4 non-HCA-CRKp clinical (*crkp_conothca_clinical*)
```{r message=FALSE, warning=FALSE, include=TRUE}

#### Plot data, ACF, PACF

tswide_clean <- tswide_clean %>% as_tsibble(index=date)

tswide_clean %>% gg_tsdisplay(crkp_conothca_clinical, "partial")


#### Is the series stationary? Apply a unit root test to check if time-series stationary,  determine number of non-seasonal (ndiffs) and seasonal (nsdiffs) differences required to make stationary, and plot differenced time-series if required.
tswide_clean %>% features(crkp_conothca_clinical, unitroot_kpss)
tswide_clean %>% features(crkp_conothca_clinical, unitroot_ndiffs) 
tswide_clean %>% features(crkp_conothca_clinical, unitroot_nsdiffs,.period=12) 

#### Examine need for a Box-Cox data transformation to reduce heteroskedasticity (i.e variability in the variance of the time-series)
lambda<-guerrero(tswide_clean$crkp_conothca_clinical, .period=12L)

#### create new transformed variable
tswide_clean$crkp_conothca_clinical_bc <- (((tswide_clean$crkp_conothca_clinical)^lambda)-1)/lambda

####  Plot the transformed variable, ACF, PACF
tswide_clean %>% gg_tsdisplay(crkp_conothca_clinical_bc, "partial")

#### Repeat unit root tests and differencing number evaluations on the transformed data
tswide_clean %>% features(crkp_conothca_clinical_bc, unitroot_kpss) # marginal
tswide_clean %>% features(crkp_conothca_clinical_bc, unitroot_ndiffs) 
tswide_clean %>% features(crkp_conothca_clinical_bc, unitroot_nsdiffs,.period=12) 

tswide_clean %>% gg_tsdisplay(difference(crkp_conothca_clinical_bc), "partial")  

# fit best manual and auto ARIMA with default approach for NON-TRANSFORMED data
arima_crkp_conothca <- tswide_clean %>% model(
  arima_crkp_conothca_101 = ARIMA(
    crkp_conothca_clinical ~ pdq(1,0,1)),
  stepwise_crkp_conothca = ARIMA(
    crkp_conothca_clinical)) 

glance(arima_crkp_conothca) %>% arrange(AICc) %>% dplyr::select(.model:BIC)
arima_crkp_conothca  %>% dplyr::select(arima_crkp_conothca_101) %>% gg_tsresiduals() # compare models
arima_crkp_conothca %>% dplyr::select(stepwise_crkp_conothca) %>% gg_tsresiduals() # compare models


#### Fit best manual and auto ARIMA on transformed data
arima_crkp_conothca_bc <- tswide_clean %>% model(
  arima_crkp_conothca_bc_111 = ARIMA(
    crkp_conothca_clinical_bc ~ pdq(1,1,1)),
  arima_crkp_conothca_bc_011 = ARIMA(
    crkp_conothca_clinical_bc ~ pdq(0,1,1)),
  arima_crkp_conothca_bc_101 = ARIMA(
    crkp_conothca_clinical_bc ~ pdq(1,0,1)),
  stepwise_crkp_conothca_bc = ARIMA(
    crkp_conothca_clinical_bc)) 

glance(arima_crkp_conothca_bc) %>% arrange(AICc) %>% dplyr::select(.model:BIC)

arima_crkp_conothca_bc  %>% dplyr::select(arima_crkp_conothca_bc_111) %>% gg_tsresiduals() # compare models
arima_crkp_conothca_bc %>% dplyr::select(stepwise_crkp_conothca_bc) %>% gg_tsresiduals() # compare models

#### Check portmanteau tests of best fit option
augment(arima_crkp_conothca_bc) %>% 
  filter(.model=='arima_crkp_conothca_bc_011') %>%
  features(.innov, ljung_box, lag = 10, dof = 3)  #portmanteau test on best manual



```




### 3.2.5 non-HCA-CRAb clinical (*crab_conothca_clinical*)
```{r message=FALSE, warning=FALSE, include=TRUE}

#### Plot data, ACF, PACF

tswide_clean <- tswide_clean %>% as_tsibble(index=date)

tswide_clean %>% gg_tsdisplay(crab_conothca_clinical, "partial")


#### Is the series stationary? Apply a unit root test to check if time-series stationary,  determine number of non-seasonal (ndiffs) and seasonal (nsdiffs) differences required to make stationary, and plot differenced time-series if required.
tswide_clean %>% features(crab_conothca_clinical, unitroot_kpss)
tswide_clean %>% features(crab_conothca_clinical, unitroot_ndiffs) 
tswide_clean %>% features(crab_conothca_clinical, unitroot_nsdiffs,.period=12) 

#### Examine need for a Box-Cox data transformation to reduce heteroskedasticity (i.e variability in the variance of the time-series)
lambda<-guerrero(tswide_clean$crab_conothca_clinical, .period=12L)

#### create new transformed variable
tswide_clean$crab_conothca_clinical_bc <- (((tswide_clean$crab_conothca_clinical)^lambda)-1)/lambda

####  Plot the transformed variable, ACF, PACF
tswide_clean %>% gg_tsdisplay(crab_conothca_clinical_bc, "partial")

#### Repeat unit root tests and differencing number evaluations on the transformed data
tswide_clean %>% features(crab_conothca_clinical_bc, unitroot_kpss) # marginal
tswide_clean %>% features(crab_conothca_clinical_bc, unitroot_ndiffs) 
tswide_clean %>% features(crab_conothca_clinical_bc, unitroot_nsdiffs,.period=12) 

tswide_clean %>% gg_tsdisplay(difference(crab_conothca_clinical_bc), "partial")  

# fit best manual and auto ARIMA with default approach for NON-TRANSFORMED data
arima_crab_conothca <- tswide_clean %>% model(
  arima_crab_conothca_101 = ARIMA(
    crab_conothca_clinical ~ pdq(1,0,1)),
  stepwise_crab_conothca = ARIMA(
    crab_conothca_clinical)) 

glance(arima_crab_conothca) %>% arrange(AICc) %>% dplyr::select(.model:BIC)
arima_crab_conothca  %>% dplyr::select(arima_crab_conothca_101) %>% gg_tsresiduals() # compare models
arima_crab_conothca %>% dplyr::select(stepwise_crab_conothca) %>% gg_tsresiduals() # compare models


#### Fit best manual and auto ARIMA on transformed data
arima_crab_conothca_bc <- tswide_clean %>% model(
  arima_crab_conothca_bc_111 = ARIMA(
    crab_conothca_clinical_bc ~ pdq(1,1,1)),
  arima_crab_conothca_bc_011 = ARIMA(
    crab_conothca_clinical_bc ~ pdq(0,1,1)),
  arima_crab_conothca_bc_001 = ARIMA(
    crab_conothca_clinical_bc ~ pdq(0,0,1)),
  stepwise_crab_conothca_bc = ARIMA(
    crab_conothca_clinical_bc)) 

glance(arima_crab_conothca_bc) %>% arrange(AICc) %>% dplyr::select(.model:BIC)

arima_crab_conothca_bc  %>% dplyr::select(arima_crab_conothca_bc_011) %>% gg_tsresiduals() # compare models
arima_crab_conothca_bc %>% dplyr::select(stepwise_crab_conothca_bc) %>% gg_tsresiduals() # compare models

#### Check portmanteau tests of best fit option
augment(arima_crab_conothca_bc) %>% 
  filter(.model=='arima_crab_conothca_bc_011') %>%
  features(.innov, ljung_box, lag = 10, dof = 3)  #portmanteau test on best manual



```


### 3.2.6 non-HCA-CRPa clinical (*crpa_conothca_clinical*)
```{r message=FALSE, warning=FALSE, include=TRUE}

#### Plot data, ACF, PACF

tswide_clean <- tswide_clean %>% as_tsibble(index=date)

tswide_clean %>% gg_tsdisplay(crpa_conothca_clinical, "partial")


#### Is the series stationary? Apply a unit root test to check if time-series stationary,  determine number of non-seasonal (ndiffs) and seasonal (nsdiffs) differences required to make stationary, and plot differenced time-series if required.
tswide_clean %>% features(crpa_conothca_clinical, unitroot_kpss)
tswide_clean %>% features(crpa_conothca_clinical, unitroot_ndiffs) 
tswide_clean %>% features(crpa_conothca_clinical, unitroot_nsdiffs,.period=12) 

#### Examine need for a Box-Cox data transformation to reduce heteroskedasticity (i.e variability in the variance of the time-series)
lambda<-guerrero(tswide_clean$crpa_conothca_clinical, .period=12L)

#### create new transformed variable
tswide_clean$crpa_conothca_clinical_bc <- (((tswide_clean$crpa_conothca_clinical)^lambda)-1)/lambda

####  Plot the transformed variable, ACF, PACF
tswide_clean %>% gg_tsdisplay(crpa_conothca_clinical_bc, "partial")

#### Repeat unit root tests and differencing number evaluations on the transformed data
tswide_clean %>% features(crpa_conothca_clinical_bc, unitroot_kpss) # marginal
tswide_clean %>% features(crpa_conothca_clinical_bc, unitroot_ndiffs) 
tswide_clean %>% features(crpa_conothca_clinical_bc, unitroot_nsdiffs,.period=12) 

tswide_clean %>% gg_tsdisplay(difference(crpa_conothca_clinical_bc), "partial")  

# fit best manual and auto ARIMA with default approach for NON-TRANSFORMED data
arima_crpa_conothca <- tswide_clean %>% model(
  arima_crpa_conothca_101 = ARIMA(
    crpa_conothca_clinical ~ pdq(1,0,1)),
  stepwise_crpa_conothca = ARIMA(
    crpa_conothca_clinical)) 

glance(arima_crpa_conothca) %>% arrange(AICc) %>% dplyr::select(.model:BIC)
arima_crpa_conothca  %>% dplyr::select(arima_crpa_conothca_101) %>% gg_tsresiduals() # compare models
arima_crpa_conothca %>% dplyr::select(stepwise_crpa_conothca) %>% gg_tsresiduals() # compare models


#### Fit best manual and auto ARIMA on transformed data
arima_crpa_conothca_bc <- tswide_clean %>% model(
  arima_crpa_conothca_bc_011 = ARIMA(
    crpa_conothca_clinical_bc ~ pdq(0,1,1)),
  arima_crpa_conothca_bc_101 = ARIMA(
    crpa_conothca_clinical_bc ~ pdq(1,0,1)),
  arima_crpa_conothca_bc_001 = ARIMA(
    crpa_conothca_clinical_bc ~ pdq(0,0,1)),
  stepwise_crpa_conothca_bc = ARIMA(
    crpa_conothca_clinical_bc)) 

glance(arima_crpa_conothca_bc) %>% arrange(AICc) %>% dplyr::select(.model:BIC)

arima_crpa_conothca_bc  %>% dplyr::select(arima_crpa_conothca_bc_011) %>% gg_tsresiduals() # compare models
arima_crpa_conothca_bc %>% dplyr::select(stepwise_crpa_conothca_bc) %>% gg_tsresiduals() # compare models

#### Check portmanteau tests of best fit option
augment(arima_crpa_conothca_bc) %>% 
  filter(.model=='arima_crpa_conothca_bc_011') %>%
  features(.innov, ljung_box, lag = 10, dof = 3)  #portmanteau test on best manual



```


## 3.3 Antibiotic and IPC time series

```{r}

# Nb: we use the pre-intervention dataset "ts_p2_pre_icarba" for fitting the baseline ARIMA with exogenous variables (ARIMAX) for carbapenems. For other antibiotics we should use the  "ts_p3_pre_iabs_iunivscr" data
pre_icarba <- ts_p2_pre_icarba %>% as_tsibble(index="date")
pre_iabs <- ts_p3_pre_iabs_iunivscr %>% as_tsibble(index="date")



```

## 3.3 Influential infection time-series

These time-series are expected to be related to antibiotic use in the population. Bidirectional relationships may exist but we hypothesised that hospital-wide use of important antibiotic exposures driving epidemiology of CROs may respond as follows:
- 3GC

-   All gram-negative bloodstream isolates (BSIs) (*gmneg_all_bsi*)
-   Carbapenem and cephalosporin sensitive E.coli BSI (*ecoliccs_all_bsi*)
-   3rd generation cephalosporins resistant E.coli BSI (*ecoli3gcr_all_bsi*)

### 3.3.1 Gram-Neg BSIs


# 4. ARIMAX cross-correlations
In this section we look at temporal correlations between variables hypothesised to be related. In particular:

* 4.1   Gram-negative clinical infections and fluoroquinolonoes (fq),
3rd generation cephalosporins (3gc), anti-pseudomonal 3rd gen cephalosporins (pseudo-3gc)
* 4.2   ESBL E.coli infections and carbapenems
* 4.4  Importation pressure and infections or colonisations (each CRO)
* 4.5  Population interactions (hca vs. non-hca for each CRO)
* 4.4  


## 4.1 All GN infections and abx use

### 4.1.2 All monitor abx
```{r message=FALSE, warning=FALSE, include=TRUE}

#----------------------------------------
# Select variables
X = ts_p2
vars<- c("date", "cskp_all_clinical", "gmneg_all_clinical", "all_monitor_abx",
  "ecoli_esbl_all_clinical")

X <- X %>% as_tsibble() %>% dplyr::select(vars)

Xlong<- X %>% as_tsibble() %>% pivot_longer(cols=(!date), names_to="variable",values_to="value")

Xlongd<- Xlong %>% as_tibble () %>% 
  group_by(variable) %>% 
  mutate(diff_var = difference(value))

X<- X %>% ts()
#----------------
# Plots
tsplot<-ggplot(Xlongd, aes(date, value, color=variable))+
  geom_line()+
  facet_grid(variable~., scales="free_y")+
  scale_y_continuous("Original variables")+
  theme_pnaat()+
  theme(panel.grid=element_blank())

tsdplot <- ggplot(Xlongd, aes(date, 
 diff_var, color=variable))+
  geom_line()+
  geom_hline(yintercept=0, linetype="dashed",
             color="grey")+
  facet_grid(variable~., scales="free_y")+
  scale_y_continuous("First differenced variables")+
  theme_pnaat()+
  theme(panel.grid=element_blank())

tsplot+tsdplot+plot_layout(guides="collect")

#----------------------------------------
# Check for stationarity


#----------------------------------------
# Check for stationarity

adf.matrix<-rep(0,2) 

adfs_and_diffs <-function(X){
for(i in 1:length(X[1,])){
endo_var<- X[,i]
adf1<- adfTest(endo_var, type="c")@test$p.value 
adf2<- adfTest(endo_var, type="ct")@test$p.value 
adfs <-cbind(adf1,adf2)
adf.matrix <-rbind(adf.matrix, adfs) 
}
  
adf.matrix<-adf.matrix[-1,]
nam<-c(paste0(colnames(X)))
adftab<-cbind(nam,adf.matrix) %>% as_tibble() 
adftab <-adftab %>% mutate(conclusion=
  if_else(adf1<0.05,"stationary in level",
          if_else(adf2<0.05, "stationary in trend","nonstationary")))
}

adfs <- adfs_and_diffs(X)
adfs

#
CCF(ts_p3, difference(cephs),
    difference(gmneg_all_clinical), lag_max=24) %>% autoplot(level=95)


%>%
  # Restrict data so models use same fitting period
  mutate(ed_3gc = c(NA, NA, NA,NA, ts_p3$`3gc`[5:80])) %>%
  # Estimate models
  model(
    lag0 = ARIMA(3gc ~ pdq(d = 0) + TVadverts),
    lag1 = ARIMA(Quotes ~ pdq(d = 0) +
                 TVadverts + lag(TVadverts)),
    lag2 = ARIMA(Quotes ~ pdq(d = 0) +
                 TVadverts + lag(TVadverts) +
                 lag(TVadverts, 2)),
    lag3 = ARIMA(Quotes ~ pdq(d = 0) +
                 TVadverts + lag(TVadverts) +
                 lag(TVadverts, 2) + lag(TVadverts, 3))
  )
# Prepare differenced time-series
pre_icarba$gmneg_diff <-  tsibble::difference(pre_icarba$gmneg_all_bsi, lag =1, differences = 1)
pre_icarba$carbapenem_diff <-  tsibble::difference(pre_icarba$carbapenem, lag =1, differences = 1)
pre_icarba_ed2 <- pre_icarba [2:72,] %>% as_tsibble(index="date")
pre_icarba_ed4 <- pre_icarba [4:72,] %>% as_tsibble(index="date")

# Explore cross-correlations with raw data
CCF(pre_icarba, carbapenem, gmneg_all_bsi, lag_max=24) %>% autoplot(level=95)

# Explore cross-correlations with differenced data
CCF(pre_icarba_ed2, carbapenem_diff, gmneg_diff, lag_max=24)%>% autoplot(level=95)

# Identify an ARIMAX model for carbapenems 
carba_pre1 <- pre_icarba %>% model(ARIMA(carbapenem~ -1 + pdq(1,1,0)+PDQ(0,0,0)+lag(gmneg_all_bsi,2)))
report(carba_pre1)
carba_pre1 %>%  gg_tsresiduals() 

carba_pre2 <- pre_icarba_ed2 %>% model(ARIMA(carbapenem  ~ -1 + pdq(1,1,0)+PDQ(0,0,0)+lag(gmneg_diff,2)))
report(carba_pre2)
carba_pre2 %>%  gg_tsresiduals() 

# Looking at the correlation between gm neg BSI and differenced gm neg BSI (y-axis)
gmneg_bsi<- pre_icarba$gmneg_all_bsi[1:71]
differenced_gm_negbsi <- pre_icarba$gmneg_diff [2:72]
gmneg <- cbind(gmneg_bsi,differenced_gm_negbsi )
gmneg <-gmneg %>% as_tibble()
cor(gmneg$gmneg_bsi, gmneg$differenced_gm_negbsi)
ggplot(gmneg, aes(gmneg_bsi,differenced_gm_negbsi))+geom_point()


CCF(ts_p3, difference(cephs),
    difference(gmneg_all_clinical), lag_max=24) %>% autoplot(level=95)


CCF(ts_p3, difference(cephs),
    difference(gmneg_all_clinical), lag_max=24) %>% autoplot(level=95)

CCF(ts_p3, difference(fq),
    difference(gmneg_all_clinical), lag_max=24) %>% autoplot(level=95)

CCF(ts_p3, difference(pseudo_3gc),
    difference(gmneg_all_clinical), lag_max=24) %>% autoplot(level=95)

CCF(ts_p3, difference(other_monitor_abx),
    difference(gmneg_all_clinical), lag_max=24) %>% autoplot(level=95)

CCF(ts_p3, difference(all_monitor_abx),
    difference(gmneg_all_clinical), lag_max=24) %>% autoplot(level=95)

CCF(ts_p3, difference(noncarb),
    difference(gmneg_all_clinical), lag_max=24) %>% autoplot(level=95)



CCF(ts_p3, difference(cephs),
    difference(ecoli_esbl_all_clinical), lag_max=24) %>% autoplot(level=95)

CCF(ts_p3, difference(fq),
    difference(ecoli_esbl_all_clinical), lag_max=24) %>% autoplot(level=95)

CCF(ts_p3, difference(pseudo_3gc),
    difference(ecoli_esbl_all_clinical), lag_max=24) %>% autoplot(level=95)

CCF(ts_p3, difference(other_monitor_abx),
    difference(ecoli_esbl_all_clinical), lag_max=24) %>% autoplot(level=95)

CCF(ts_p3, difference(all_monitor_abx),
    difference(ecoli_esbl_all_clinical), lag_max=24) %>% autoplot(level=95)

CCF(ts_p3, difference(ecoli_esbl_all_clinical), difference(carbapenem),
    lag_max=24) %>% autoplot(level=95)


```

```{r}
### Fluorquinolones ######################

# Prepare differenced time-series
# pre_icarba$gmneg_diff <-  tsibble::difference(pre_icarba$gmneg_all_bsi, lag =1, differences = 1)
pre_icarba$fq_diff <-  tsibble::difference(pre_icarba$fq, lag =1, differences = 1)
pre_icarba_ed2 <- pre_icarba [2:72,] %>% as_tsibble(index="date")
pre_icarba_ed4 <- pre_icarba [4:72,] %>% as_tsibble(index="date")

# Explore cross-correlations with raw data
CCF(pre_icarba, fq, gmneg_all_bsi, lag_max=24) %>% autoplot(level=95)

# Explore cross-correlations with differenced data
CCF(pre_icarba_ed2, fq_diff, gmneg_diff, lag_max=24)%>% autoplot(level=95)

# Identify an ARIMAX model for carbapenems 

fq_pre1 <- pre_icarba %>% model(ARIMA(fq~ -1 + pdq(0,1,1)+PDQ(0,0,0)+lag(gmneg_all_bsi,1) ))
report(fq_pre1)
fq_pre1 %>%  gg_tsresiduals() 

fq_pre2 <- pre_icarba_ed2 %>% model(ARIMA(fq  ~ -1 + pdq(0,1,1)+PDQ(0,0,0)+lag(gmneg_diff,1)))
report(fq_pre2)
fq_pre2 %>%  gg_tsresiduals() 


```


### 4.1.3 Carbapenems
```{r}

#--------------------------------------------------------------
# Check for stationarity
#--------------------------------------------------------------
adf.test(ts_p2$carbapenem)
unitroot_ndiffs(ts_p2$carbapenem)
                
auto.arima(ts_p2$carbapenem,
           allowdrift = FALSE, 
           allowmean=TRUE,
           max.q = 0, 
           xreg = cbind(lag(ts_p2$gmneg_all_bsi,2)))
           

auto.arima(difference(ts_p2$carbapenem),
           allowdrift = FALSE, 
           allowmean=TRUE,
           max.q = 0, 
           xreg = cbind(lag(difference(ts_p2$gmneg_all_bsi),2)))


arimax_carbapenem <-Arima(ts_p2$carbapenem, order = c(1,1,0), include.drift = FALSE)
coeftest(arimax_carbapenem)
Acf(arimax_carbapenem$residuals)
AIC(arimax_carbapenem)

arimax_carbapenem_enhanced <-Arima(ts_p2$carbapenem, order = c(1,1,0), include.drift = FALSE,xreg = lag(ts_p2$gmneg_all_bsi,2))
coeftest(arimax_carbapenem_enhanced)
Acf(arimax_carbapenem_enhanced$residuals)

AIC(arimax_carbapenem_enhanced)

gmneg_all_future  <-tswide$gmneg_all_bsi[73:132]

carb_forecast <-forecast::forecast(
  arimax_carbapenem,h = 60) 

carb_forecast_enhanced<-forecast::forecast(
  arimax_carbapenem_enhanced ,h = 60, xreg = gmneg_all_future)

autoplot(carb_forecast)
autoplot(carb_forecast_enhanced)
```
```{r}

adf.test(pre_icarba$fq)
unitroot_ndiffs(pre_icarba$fq)
auto.arima(pre_icarba$fq,allowdrift = TRUE,max.q = 0,xreg = cbind(lag(pre_icarba$gmneg_all_bsi,1)))

model.pre_icarba.fq<-Arima(pre_icarba$fq,order = c(1,0,0),include.drift = TRUE, xreg = cbind(lag(pre_icarba$gmneg_all_bsi,1)))
summary(model.pre_icarba.fq)
coeftest(model.pre_icarba.fq)
Acf(model.pre_icarba.fq$residuals)
AIC(model.pre_icarba.fq)

gmneg_all_future  <-tswide_clean$gmneg_all_bsi[73:132]

fore.icarba.fq<-forecast(model.pre_icarba.fq,h = 60, xreg = gmneg_all_future) 
autoplot(fore.icarba.fq)


```

```{r}

adf.test(pre_icarba$x3gc)
unitroot_ndiffs(pre_icarba$x3gc)
auto.arima(pre_icarba$x3gc)
auto.arima(pre_icarba$x3gc,allowdrift = TRUE,max.q = 0,xreg = cbind(lag(pre_icarba$gmneg_all_bsi,4)))
model.pre_icarba.x3gc<-Arima(pre_icarba$x3gc,order = c(1,0,0), include.drift = TRUE, xreg = lag(pre_icarba$gmneg_all_bsi,4))
summary(model.pre_icarba.x3gc)
coeftest(model.pre_icarba.x3gc)
Acf(model.pre_icarba.x3gc$residuals)
AIC(model.pre_icarba.x3gc)

gmneg_all_future  <-tswide_clean$gmneg_all_bsi[73:132]

fore.icarba.x3gc<-forecast(model.pre_icarba.x3gc,h = 60, xreg = gmneg_all_future) 
autoplot(fore.icarba.x3gc)


```


# 5. Interactions and VARs
We used VAR/VECM to check the directionality of hypothesised relationships as described in the logic diagram of the paper.
In particular we examined sub-systems as follows:
5.1. Relations between general gram negative infection ecology & antibiotic use
5.2. Inter-species competition
5.3. Within-species (CSO vs. CRO) competition
5.4  Relations between CRO burdens in HO-HCA, CO-HCA, and CO-non-HCA
5.5  Relations between importation pressure and CRO burdens
## 5.1 Define functions for VAR
```{r}

eval_var<-function(y, series, names){

  # Make series to be stationary
 
dy=0; dseries=0

if(unitroot_ndiffs(ts(y), alpha=0.05)!=0){dy<-unitroot_ndiffs(ts(y), alpha=0.05);y<-diff(ts(y), differences=dy)}
if(unitroot_ndiffs(ts(series), alpha=0.05)!=0){dseries<-unitroot_ndiffs(ts(series), alpha=0.05); series<-diff(ts(series), differences=dseries)}

if(dy>dseries){series<-head(series,-I(dy-dseries))}
if(dy<dseries){y<-head(y,-I(dseries-dy))}    

assign(names[1],y)
assign(names[2],series)

  # Select order and estimate VAR
matrix<-cbind(y,series)
colnames(matrix)<-names

var.fit <- vars::VAR(matrix,lag.max = 2, type=c("none"))
summary(var.fit)
  # Some test form var estimation
serial.test<-serial.test(var.fit, lags.pt=10, type="PT.asymptotic")

normality.test <- normality.test(var.fit)

var.stability <- stability(var.fit, type = "Rec-CUSUM")

   # Impulse response function

impulse.response <- vars::irf(var.fit , n.ahead = 6, ortho = TRUE,
               cumulative = F, boot = TRUE, ci = 0.95, runs = 100)

  # Variance decomposition of the forecasts

var.decomp<-fevd(var.fit)

  # causality analysis

causality<- list(cause.y=causality(var.fit,  cause=names[1],boot=TRUE, boot.runs=1000)$Granger, cause.series=causality(var.fit, cause=names[2], boot=TRUE, boot.runs=1000)$Granger)


return(
  list(
    var.fit=var.fit,
    causality=causality,
    impulse.response=impulse.response,
    serial.test=serial.test,
    normality.test=normality.test,
    var.stability=var.stability,
    var.decomp=var.decomp
    )
  )
}




eval_var3<-function(x,y,z,names){


  # Make series to be stationary
 
dx=0; dy=0 ; dz=0
if(unitroot_ndiffs(ts(x), alpha=0.05)!=0){dx<-unitroot_ndiffs(ts(x), alpha=0.05);x<-diff(ts(x), differences=dx)}
if(unitroot_ndiffs(ts(y), alpha=0.05)!=0){dy<-unitroot_ndiffs(ts(y), alpha=0.05);y<-diff(ts(y), differences=dy)}
if(unitroot_ndiffs(ts(z), alpha=0.05)!=0){dz<-unitroot_ndiffs(ts(z), alpha=0.05);z<-diff(ts(z), differences=dz)}

maxd<-max(dx,dy,dz)

if(dx<maxd){x<-head(x,-I(maxd-dx))}
if(dy<maxd){y<-head(y,-I(maxd-dy))}    
if(dz<maxd){z<-head(z,-I(maxd-dz))}    


assign(names[1],x)
assign(names[2],y)
assign(names[3],z)

  # Select order and estimate VAR
matrix<-cbind(x,y,z)
colnames(matrix)<-names

var.fit <- VAR(matrix, lag.max =2)

  # Some test form var estimation

serial.test<-serial.test(var.fit, lags.pt=10, type="PT.asymptotic")

normality.test <- normality.test(var.fit)

var.stability <- stability(var.fit, type = "Rec-CUSUM")
   
  # Impulse response function

impulse.response <- irf(var.fit , n.ahead = 6, ortho = TRUE,
               cumulative = F, boot = TRUE, ci = 0.95, runs = 100)

  # Variance decomposition of the forescats

var.decomp<-fevd(var.fit)

# causality analisys

causality<- list(
  cause.x=causality(var.fit,  cause=names[1],boot=TRUE, boot.runs=1000)$Granger,
  cause.y=causality(var.fit,  cause=names[2],boot=TRUE, boot.runs=1000)$Granger,
  cause.z=causality(var.fit,  cause=names[3],boot=TRUE, boot.runs=1000)$Granger)
 

return(
  list(
    var.fit=var.fit,
    causality=causality,
    impulse.response=impulse.response,
    serial.test=serial.test,
    normality.test=normality.test,
    var.stability=var.stability,
    var.decomp=var.decomp
    )
  )
}


eval_var4<-function(x,y,z,zz,names){


  # Make series to be stationary
 
dx=0; dy=0 ; dz=0; dzz=0
if(unitroot_ndiffs(ts(x), alpha=0.05)!=0){dx<-unitroot_ndiffs(ts(x), alpha=0.05);x<-diff(ts(x), differences=dx)}
if(unitroot_ndiffs(ts(y), alpha=0.05)!=0){dy<-unitroot_ndiffs(ts(y), alpha=0.05);y<-diff(ts(y), differences=dy)}
if(unitroot_ndiffs(ts(z), alpha=0.05)!=0){dz<-unitroot_ndiffs(ts(z), alpha=0.05);z<-diff(ts(z), differences=dz)}
if(unitroot_ndiffs(ts(zz), alpha=0.05)!=0){dz<-unitroot_ndiffs(ts(zz), alpha=0.05);zz<-diff(ts(zz), differences=dzz)}


maxd<-max(dx,dy,dz,dzz)

if(dx<maxd){x<-head(x,-I(maxd-dx))}
if(dy<maxd){y<-head(y,-I(maxd-dy))}    
if(dz<maxd){z<-head(z,-I(maxd-dz))}    
if(dzz<maxd){zz<-head(zz,-I(maxd-dzz))}    

assign(names[1],x)
assign(names[2],y)
assign(names[3],z)
assign(names[4],zz)

  # Select order and estimate VAR
matrix<-cbind(x,y,z,zz)
colnames(matrix)<-names

var.fit <- VAR(matrix, lag.max =2)

  # Some test form var estimation

serial.test<-serial.test(var.fit, lags.pt=10, type="PT.asymptotic")

normality.test <- normality.test(var.fit)

var.stability <- stability(var.fit, type = "Rec-CUSUM")
   
  # Impulse response function

impulse.response <- irf(var.fit , n.ahead = 6, ortho = TRUE,
               cumulative = F, boot = TRUE, ci = 0.95, runs = 100)

  # Variance decomposition of the forescats

var.decomp<-fevd(var.fit)

# causality analisys

causality<- list(
  cause.x=causality(var.fit,  cause=names[1],boot=TRUE, boot.runs=1000)$Granger,
  cause.y=causality(var.fit,  cause=names[2],boot=TRUE, boot.runs=1000)$Granger,
  cause.z=causality(var.fit,  cause=names[3],boot=TRUE, boot.runs=1000)$Granger,  
  cause.zz=causality(var.fit,  cause=names[4],boot=TRUE, boot.runs=1000)$Granger)
 

return(
  list(
    var.fit=var.fit,
    causality=causality,
    impulse.response=impulse.response,
    serial.test=serial.test,
    normality.test=normality.test,
    var.stability=var.stability,
    var.decomp=var.decomp
    )
  )
}

```

## 5.1 Gram-Negative infections and antibiotic use
```{r}



```

## 5.1 Gram-Negative infections and antibiotic use
```{r}



```



```{r}

#---------------------------------------------------------------------
### 1) Summarising all non-carbapenem abx as a single TS
#----------------------------------------
# Select variables
#----------------------------------------
noncarb_var<- ts_p2 %>% as_tibble() %>% dplyr::select(
  gmneg_all_clinical, 
  ecoli_esbl_all_clinical,
  carbapenem,
  noncarb) %>% ts()

class(noncarb_var)


cor(noncarb_var) #Printing the correlation matrix


#----------------------------------------
# Check for unit roots of individual TS before and after differencing to establish whether original TS are non-stationary (and therefore need either VEC or differencing)
#----------------------------------------
apply(noncarb_var, 2, adf.test) #Apply Unit Root tests to all TS
noncarb_vard<- diffM(noncarb_var, d = 1) # Difference all vars
apply(noncarb_vard, 2, adf.test) # check if single differencing makes stationary

for (i in 1:ncol(X)){
    print(colnames(X)[i]) #Prints the name of the time-series tested for stationarity to the R console.
    options(warn=-1)
    unitroot_trend<-adfTest(X[,i], type="c")@test$p.value #Checks for trend-stationarity of all series in the rolling window separately; if significant, means lack of trend in the series.
    unitroot_const<-adfTest(X[,i], type="ct")
    }



#----------------------------------------
# Plots of box-cox transformed and box-cox transformed with differencing TS
#----------------------------------------
autoplot(ts(noncarb_var)) +
  ggtitle("Non-carbapenem, Carbapenem, Gram-Neg, and ESBL Time-Series")

autoplot(ts(noncarb_vard)) +
  ggtitle("Non-carbapenem, Carbapenem, Gram-Neg, and ESBL Time-Series (differenced)")

#----------------------------------------
# Determine the optimal lag (max) to include
#----------------------------------------
decompose <- function(data, y, ...){
    y <- enquo(y)
    dvar <- data %>% dplyr::pull(!!y) %>% as.ts()
    tmpd <- data %>% model(STL(dvar ~ trend(window = 21) + 
                                 season(window =13), 
                               robust = TRUE)) %>%
      components()
}


rem_gmneg<-decompose(tswide_clean, gmneg_all_clinical)[[6]]
rem_esbl<-decompose(tswide_clean, ecoli_esbl_all_clinical)[[6]]
rem_carba<-decompose(tswide_clean, carbapenem)[[6]]
rem_noncarb<-decompose(tswide_clean, noncarb)[[6]]

rems<- cbind(rem_gmneg, rem_esbl, rem_carba, rem_noncarb) %>% ts()

VARselect(rems, type = "none", lag.max = 10) #highest lag order
VARselect(noncarb_var, type = "trend", lag.max = 10) #highest lag order
VARselect(noncarb_var, type = "const", lag.max = 10) #highest lag order

#--------------------------------------------------
# Run the Johansen co-integration test
# K should equal the lag order suggested above
#---------------------------------------------------
cajo_noncarb_var<- ca.jo(type="eigen", noncarb_var, ecdet="trend", K=2,
                         spec="transitory",season=12, dumvar=NULL)
 
summary(cajo_noncarb_var)
cajorls(cajo_noncarb_var)

#----------------------------------------
# Run a VECM in 'tsDyn'
# Notes: 
# r   =  # of cointegrating relationships. 
# lag = lag of diff in y (or lag of y-1)
#----------------------------------------
VECM_tsDyn_noncarb<- VECM(noncarb_var, lag=1, r = 1, estim = "ML", LRinclude = "none")


summary(VECM_tsDyn_noncarb)
##export to Latex
toLatex(VECM_tsDyn_noncarb)
toLatex(summary(VECM_tsDyn_noncarb))
options("show.signif.stars"=FALSE)
toLatex(summary(VECM_tsDyn_noncarb), parenthese="Pvalue")
options("show.signif.stars"=TRUE)
print(xtable(ECM_tsDyn_noncarb, type = "latex"))
      
#---------------------------------------------------------------------------
# Run a VAR in levels accunting for cointegrating relations in 'vars' package
# Notes: r= # of cointegrating relationships. lag= 
#--------------------------------------------------------------------------
vec2var_noncarb<- vec2var(cajo_noncarb_var, r=1)
vec2var_noncarb


#--------------------------------------------------------------------------
# Forecast from VECM() in tsDyn
#--------------------------------------------------------------------------
# How many time-periods ahead to forecast

nr_lev=nrow(noncarb_var)
nfor=132-nr_lev

VECM_pred_tsDyn <- predict(VECM_tsDyn_noncarb, n.ahead=nfor)

# historical data + forecast data
df <- rbind(noncarb_var, VECM_pred_tsDyn)
dat<- seq(1,132,1)
df <-as_tibble(cbind(dat,df)) 
df %>% as_tsibble(index=dat)

ggplot(df, aes(dat, carbapenem))+geom_line()+scale_y_continuous(limits=c(0,NA))
ggplot(df, aes(dat, noncarb))+geom_line()+scale_y_continuous(limits=c(0,NA))
ggplot(df, aes(dat, ecoli_esbl_all_clinical))+geom_line()+scale_y_continuous(limits=c(0,NA))
```


```{r}

#----------------------------------------
# Select variables
#----------------------------------------

tswide$cleani
names<-c("clinical","swab")
var<-eval_var(tswide_clean$crkp_hca_clinical, tswide_clean$crkp_co, names)
var$impulse.response


# Defining function for VAR evaluation 2 variables y and series
eval_var<-function(y, series, names){

# Make series to be stationary
  
dy=0; dseries=0

if(unitroot_ndiffs(y)!=0){dy<-unitroot_ndiffs(y);y<-diff(y, differences=dy)}
if(unitroot_ndiffs(series)!=0){dseries<-unitroot_ndiffs(series); series<-diff(series, differences=dseries)}

if(dy>dseries){series<-head(series,-I(dy-dseries))} 
if(dy<dseries){y<-head(y,-I(dseries-dy))}    

assign(names[1],y)
assign(names[2],series)

  # Select order and estimate VAR
matrix<-cbind(y,series)
colnames(matrix)<-names

var.fit <- vars::VAR(matrix,lag.max = 7)

  # Some test form var estimation
serial.test<-serial.test(var.fit, lags.pt=10, type="PT.asymptotic")

normality.test <- normality.test(var.fit)

var.stability <- stability(var.fit, type = "Rec-CUSUM")

   # Impulse response function

impulse.response <- vars::irf(var.fit , n.ahead = 6, ortho = TRUE,
               cumulative = F, boot = TRUE, ci = 0.95, runs = 100)

  # Variance decomposition of the forecasts

var.decomp<-fevd(var.fit)

  # causality analysis

causality<- list(cause.y=causality(var.fit,  cause=names[1],boot=TRUE, boot.runs=1000)$Granger, cause.series=causality(var.fit, cause=names[2], boot=TRUE, boot.runs=1000)$Granger)


return(
  list(
    var.fit=var.fit,
    causality=causality,
    impulse.response=impulse.response,
    serial.test=serial.test,
    normality.test=normality.test, 
    var.stability=var.stability,
    var.decomp=var.decomp
    )
  )
}



### VAR Gram Negative, ecoliccs ecoli3gcr( ts_p2[,18:20]) => abx( ts_p2[,5:9]) 


for (n in 18:20){
  
 for(j in 5:9){
names<-colnames(ts_p2)[c(n,j)]
var<-eval_var(y=ts_p2[,n], 
              series=ts_p2[,j],
              names=names)

#VAR.data<-data.frame(ts_p2[,n], ts_p2[,j])
#var<-VAR(VAR.data, ic="SC",lag.max = 12)
#irf<-irf(var,n.ahead = 12,ortho=TRUE,cumulative=FALSE,boot=TRUE, ci=c(0.95), runs=50)
#plot(irf)

plot(var$impulse.response)

var$causality$cause.y
var$causality$cause.series

# optional: plot(var$var.decomp)

assign(paste0(c("var",colnames(ts_p2)[n],colnames(ts_p2)[j]), sep=".", collapse = ""),
       var)
 }
}


```

Estimate VAR between swab and clinical
```{r}

ts_post2 <- tswide_clean %>% filter(tswide_clean$int_targ_screen=="T")
pathogen<-c("crkp")
pop<-c("ho", "hca")


for (n in 1:1){
  
 for(j in 1:2){

names.var<-c(paste("ts_post2$", paste(pathogen[n],pop[j],"swab",sep="_"), sep=""),paste("ts_post2$", paste(pathogen[n],pop[j],"clinical",sep="_"), sep=""))

names<-c(paste(pathogen[n],pop[j],"swab",sep="_"),paste(pathogen[n],pop[j],"clinical",sep="_"))
names0<-c("swab","clinical")   
   

var<-eval_var(y=eval( parse(text=names.var[1])), 
              series=eval( parse(text=names.var[2])),
              names=names0)
cat(paste(names[1],names[2],sep="<=>"))
plot(var$impulse.response) # It is necessary to put irf in one plot and common title for <org> <pop>

var$causality$cause.y
var$causality$cause.series
 }
}



```


Interspecies competition

```{r}

eval_var3<-function(cskp_all_any,cskp_all_any,cskp_all_any,names){


  # Make series to be stationary
  
dx=0; dy=0 ; dz=0
if(unitroot_ndiffs(x)!=0){dx<-unitroot_ndiffs(x);x<-diff(x, differences=dx)}
if(unitroot_ndiffs(y)!=0){dy<-unitroot_ndiffs(y);y<-diff(y, differences=dy)}
if(unitroot_ndiffs(z)!=0){dz<-unitroot_ndiffs(z);z<-diff(z, differences=dz)}

maxd<-max(dx,dy,dz)

if(dx<maxd){x<-head(x,-I(maxd-dx))} 
if(dy<maxd){y<-head(y,-I(maxd-dy))}    
if(dz<maxd){z<-head(z,-I(maxd-dz))}    


assign(names[1],x)
assign(names[2],y)
assign(names[3],z)

  # Select order and estimate VAR
matrix<-cbind(x,y,z)
colnames(matrix)<-names

var.fit <- VAR(matrix, lag.max =4)

  # Some test form var estimation

serial.test<-serial.test(var.fit, lags.pt=10, type="PT.asymptotic")

normality.test <- normality.test(var.fit)

var.stability <- stability(var.fit, type = "Rec-CUSUM")
   
  # Impulse response function

impulse.response <- irf(var.fit , n.ahead = 6, ortho = TRUE,
               cumulative = F, boot = TRUE, ci = 0.95, runs = 100)

  # Variance decomposition of the forescats

var.decomp<-fevd(var.fit)

# causality analisys

causality<- list(
  cause.x=causality(var.fit,  cause=names[1],boot=TRUE, boot.runs=1000)$Granger, 
  cause.y=causality(var.fit,  cause=names[2],boot=TRUE, boot.runs=1000)$Granger,
  cause.z=causality(var.fit,  cause=names[3],boot=TRUE, boot.runs=1000)$Granger)
  

return(
  list(
    var.fit=var.fit,
    causality=causality,
    impulse.response=impulse.response,
    serial.test=serial.test,
    normality.test=normality.test, 
    var.stability=var.stability,
    var.decomp=var.decomp
    )
  )
}

names<-pathogen

for( j in 1:4){

names.var<-vector()
for (n in 1:3){
names.var<-c(names.var, paste("tswide_clean$", paste(pathogen[n],pop[j],"clinical",sep="_"), sep=""))
}

x=eval( parse(text=names.var[1])) 
y=eval( parse(text=names.var[2]))
z=eval( parse(text=names.var[3]))

var<-eval_var3(x=x,y=y,z=z, names=names)

cat(paste(names[1],names[2],names[3],sep="<=>"))
plot(var$impulse.response)


var$causality$cause.x
var$causality$cause.y
var$causality$cause.z

plot(var$serial.test)
plot(var$normality.test)
plot(var$var.stability)
# optional: plot(var$var.decomp)

assign(paste0(c("var",names[1],names[2], names[3], pop[j]), sep=".", collapse = ""),var)

}

```

Interaction among sensitive and resistant strains

```{r}

pathogen0<-rbind(c("crab","crkp","crpa"),c("csab","cskp","cspa"))

pop<-c("hca")


for (n in 1:3){
  
 for(j in 1:1){

names.var<-c(paste("tswide_clean$", paste(pathogen0[1,n],pop[j],"clinical",sep="_"), sep=""),paste("tswide_clean$", paste(pathogen0[2,n],pop[j],"clinical",sep="_"), sep=""))

names<-c(paste(pathogen0[1,n],pop[j],"clinical",sep="_"),paste(pathogen0[2,n],pop[j],"clinical",sep="_"))
 
var<-eval_var(y=eval( parse(text=names.var[1])), 
              series=eval( parse(text=names.var[2])),
              names=names)

cat(paste(names[1],names[2],sep="<=>"))
plot(var$impulse.response) # It is necessary to put irf in one plot and common title for <org> <pop>

var$causality$cause.y
var$causality$cause.series

plot(var$var.decomp)

assign(paste0(c("var",names[2],names[1]), sep=".", collapse = ""),var)
 }
}

```








```{r}
library(devtools)
install_github("MatthieuStigler/tsDyn", ref="Dev94", subdir="tsDyn")  
library(tsDyn)
```

```{r}

```

# 5. GAMs

```{r}

```

# 6. MARS

```{r}

```
